{"version":3,"sources":["google.js","app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpsBA;AACA;AACA","file":"app.js","sourcesContent":["// Client ID and API key from the Developer Console\r\nvar CLIENT_ID = '505416199336-isbs2g8tr7k8f8inss9t1rjt7s0duvqd.apps.googleusercontent.com';\r\nvar API_KEY = 'AIzaSyAIyS1GoFmevvthw9AucLQ8ygTJ2NVR-04';\r\n\r\n// Array of API discovery doc URLs for APIs used by the quickstart\r\nvar DISCOVERY_DOCS = [\"https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest\"];\r\n\r\n// Authorization scopes required by the API; multiple scopes can be\r\n// included, separated by spaces.\r\nvar SCOPES = \"https://www.googleapis.com/auth/calendar\";\r\nvar t = { OTHER: \"2\", PARTY: \"3\", EAT: \"4\", ASSIGNMENT: \"5\", CLASS: \"6\", WORK: \"7\", SLEEP: \"10\", FIXED: \"11\" };\r\nvar authorizeButton = document.getElementById('authorize-button');\r\nvar signoutButton = document.getElementById('signout-button');\r\n\r\nvar allEvents = [];\r\nvar freeTime = [];\r\nvar mandatoryEvents = [];\r\nvar notMandatoryEvents = [];\r\n/**\r\n *  On load, called to load the auth2 library and API client library.\r\n */\r\nfunction handleClientLoad() {\r\n  gapi.load('client:auth2', initClient);\r\n}\r\n\r\n/**\r\n *  Initializes the API client library and sets up sign-in state\r\n *  listeners.\r\n */\r\nfunction initClient() {\r\n  gapi.client.init({\r\n    apiKey: API_KEY,\r\n    clientId: CLIENT_ID,\r\n    discoveryDocs: DISCOVERY_DOCS,\r\n    scope: SCOPES\r\n  }).then(function () {\r\n    // Listen for sign-in state changes.\r\n    gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);\r\n\r\n    // Handle the initial sign-in state.\r\n    updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());\r\n    authorizeButton.onclick = handleAuthClick;\r\n    signoutButton.onclick = handleSignoutClick;\r\n  });\r\n}\r\n\r\n/**\r\n *  Called when the signed in status changes, to update the UI\r\n *  appropriately. After a sign-in, the API is called.\r\n */\r\nfunction updateSigninStatus(isSignedIn) {\r\n  if (isSignedIn) {\r\n    authorizeButton.style.display = 'none';\r\n    signoutButton.style.display = 'block';\r\n    listUpcomingEvents();\r\n  } else {\r\n    authorizeButton.style.display = 'block';\r\n    signoutButton.style.display = 'none';\r\n  }\r\n}\r\n\r\n\r\n/**\r\n *  Sign in the user upon button click.\r\n */\r\nfunction handleAuthClick(event) {\r\n  gapi.auth2.getAuthInstance().signIn();\r\n}\r\n\r\n/**\r\n *  Sign out the user upon button click.\r\n */\r\nfunction handleSignoutClick(event) {\r\n  gapi.auth2.getAuthInstance().signOut();\r\n}\r\n\r\n/**\r\n * Append a pre element to the body containing the given message\r\n * as its text node. Used to display the results of the API call.\r\n *\r\n * @param {string} message Text to be placed in pre element.\r\n */\r\nfunction appendPre(message) {\r\n  var pre = document.getElementById('content');\r\n  var textContent = document.createTextNode(message + '\\n');\r\n  pre.appendChild(textContent);\r\n}\r\n\r\nfunction appendDelete(message, id) {\r\n  var pre = document.getElementById('content');\r\n  var textContent = document.createTextNode('\\t' + message + '\\n');\r\n  var htmlValue = document.createElement(\"button\");\r\n  htmlValue.textContent = \"Delete\";\r\n  htmlValue.onclick = function () { deleteEventClick(id) };\r\n  pre.appendChild(htmlValue);\r\n  pre.appendChild(textContent);\r\n}\r\n/**\r\n * Print the summary and start datetime/date of the next ten events in\r\n * the authorized user's calendar. If no events are found an\r\n * appropriate message is printed.\r\n */\r\nfunction listUpcomingEvents() {\r\n  gapi.client.calendar.events.list({\r\n    'calendarId': 'primary',\r\n    'timeMin': (new Date()).toISOString(),\r\n    'timeMax': new Date('2017-12-08T08:05:00+01:00').toISOString(),\r\n    'showDeleted': false,\r\n    'singleEvents': true,\r\n    'maxResults': 20,\r\n    'orderBy': 'startTime'\r\n  }).then(function (response) {\r\n    var events = response.result.items;\r\n    allEvents = events;\r\n    appendPre('Upcoming events:');\r\n    if (events.length > 0) {\r\n      for (i = 0; i < events.length; i++) {\r\n        var event = events[i];\r\n\r\n        var start = event.start.dateTime;\r\n        if (!start) {\r\n          start = event.start.date;\r\n        }\r\n        appendDelete(event.summary + ' (' + start + ')' + '(' + event.end.dateTime + ')', event.id);\r\n      }\r\n      //handle overlaps, split mandatory and non mandatory events, find windows\r\n      prepareData(events);\r\n      console.log(freeTime);\r\n      console.log(notMandatoryEvents);\r\n      console.log(mandatoryEvents);\r\n    } else {\r\n      appendPre('No upcoming events found.');\r\n    }\r\n  });\r\n}\r\n\r\nfunction prepareData(events) {\r\n  var endDate = new Date(events[0].end.dateTime);\r\n  var distance = 0;\r\n  splitPriorities(events[0]);\r\n  for (i = 1; i < events.length; i++) {\r\n    splitPriorities(events[i]);\r\n\r\n    distance = (new Date(events[i].start.dateTime) - endDate) / 1000 / 60;\r\n    if (distance >= 30) {\r\n      freeTime.push({\r\n        'startHour': endDate,\r\n        'endHour': new Date(events[i].start.dateTime),\r\n        'value': (new Date(events[i].start.dateTime) - endDate) / 1000 / 60\r\n      });\r\n    }\r\n    else if (distance < 0) {\r\n      //add buttons to delete one of them using id's\r\n      handleOverlap(events[i - 1], events[i]);\r\n    }\r\n    endDate = new Date(events[i].end.dateTime);\r\n  }\r\n\r\n}\r\n\r\nfunction splitPriorities(event) {\r\n  if (event.colorId) {\r\n    if (event.colorId == t.OTHER || event.colorId == t.PARTY) {\r\n      notMandatoryEvents.push(event);\r\n    }\r\n    else if (event.colorId == t.ASSIGNMENT) {\r\n      mandatoryEvents.push(event);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction handleOverlap(event1, event2) {\r\n  if (event1.colorId < event2.colorId) {\r\n    //delete button with event1.eventId\r\n    appendPre(\"Overlap between: \" + event1.summary + \" and \" + event2.summary + \". We recommend to delete event: \" + event2.summary);\r\n  }\r\n  else if (event1.colorId > event2.colorId) {\r\n    //delete button with event2.eventId\r\n    appendPre(\"Overlap between: \" + event1.summary + \" and \" + event2.summary + \". We recommend to delete event: \" + event1.summary);\r\n  }\r\n  else {\r\n    appendPre(\"Overlap between: \" + event1.summary + \" and \" + event2.summary + \". Events have equal priorities\");\r\n  }\r\n}\r\n\r\nfunction addEventClick(event) {\r\n\r\n  var request = gapi.client.calendar.events.insert({\r\n    'calendarId': 'primary',\r\n    'resource': event\r\n  });\r\n\r\n  request.execute(function (event) {\r\n    appendPre('Event created: ' + event.summary + \" \" + event.htmlLink);\r\n  });\r\n}\r\n\r\n\r\nfunction deleteEventClick(id) {\r\n  var request = gapi.client.calendar.events.delete({\r\n    'calendarId': 'primary',\r\n    'eventId': id\r\n  });\r\n\r\n  request.execute(function (event) {\r\n    appendPre('Event : ' + id + \" was deleted\");\r\n  })\r\n}\r\n\r\nDate.prototype.addHours = function (h) {\r\n  this.setHours(this.getHours() + h);\r\n  return this;\r\n}\r\n\r\nfunction haveOverlap(firstStart, firstEnd, secondStart, secondEnd) {\r\n  return (firstStart < secondStart && secondEnd < firstEnd)\r\n    || (secondStart < firstStart && firstEnd < secondEnd)\r\n    || (secondStart < firstEnd && firstStart < secondEnd)\r\n    || (firstStart < secondEnd && secondStart < firstEnd);\r\n}\r\n\r\nfunction deletePartially(start, end, overlapedEvent) {\r\n  var overlapedStart = new Date(overlapedEvent.start.dateTime);\r\n  var overlapedEnd = new Date(overlapedEvent.end.dateTime);\r\n  if (start < overlapedStart && overlapedEnd < end) {\r\n    //addEventClick(overlapedEvent);\r\n  }\r\n  else if (overlapedStart < start && end < overlapedEnd) {\r\n    var event = generateEvent(overlapedEvent.summary,\r\n      overlapedEvent.location,\r\n      overlapedEvent.description,\r\n      overlapedEvent.colorId,\r\n      overlapedStart.toISOString(),\r\n      start.toISOString());\r\n    addEventClick(event);\r\n\r\n    var event = generateEvent(overlapedEvent.summary,\r\n      overlapedEvent.location,\r\n      overlapedEvent.description,\r\n      overlapedEvent.colorId,\r\n      end.toISOString(),\r\n      overlapedEnd.toISOString());\r\n    addEventClick(event);\r\n  }\r\n  else if (start < overlapedEnd && overlapedEnd < end) {\r\n    var event = generateEvent(overlapedEvent.summary,\r\n      overlapedEvent.location,\r\n      overlapedEvent.description,\r\n      overlapedEvent.colorId,\r\n      overlapedStart.toISOString(),\r\n      start.toISOString());\r\n    console.log(event);\r\n    addEventClick(event);\r\n  }\r\n  else if (overlapedStart < end && end < overlapedEnd) {\r\n    var event = generateEvent(overlapedEvent.summary,\r\n      overlapedEvent.location,\r\n      overlapedEvent.description,\r\n      overlapedEvent.colorId,\r\n      end.toISOString(),\r\n      overlapedEnd.toISOString());\r\n    console.log(event);\r\n    addEventClick(event);\r\n  }\r\n  deleteEventClick(overlapedEvent.id);\r\n}\r\n\r\nfunction reasign(startAfter, overlapedEvent) {\r\n  var index = mandatoryEvents.indexOf(overlapedEvent);\r\n  console.log(index);\r\n  if(index>=0){\r\n    mandatoryEvents.splice(index,1);\r\n  }\r\n  deleteEventClick(overlapedEvent.id);\r\n  console.log(overlapedEvent);\r\n  console.log(freeTime);\r\n  console.log(mandatoryEvents);\r\n  console.log(notMandatoryEvents);\r\n  var deadline = new Date(overlapedEvent.description.split('|')[0]);\r\n  console.log(deadline);\r\n  var hours = (new Date(overlapedEvent.end.dateTime) - new Date(overlapedEvent.start.dateTime)) / 1000 / 60;\r\n  console.log(hours);\r\n  var freeUntilDeadline = [];\r\n  for (let i = 0; i < freeTime.length; i++) {\r\n    const element = freeTime[i];\r\n    if (element.endHour < deadline) {\r\n      freeUntilDeadline.push(element);\r\n    }\r\n  }\r\n  console.log(\"freeUntilDeadline\");\r\n  console.log(freeUntilDeadline);\r\n  for (let i = 0; i < freeUntilDeadline.length; i++) {\r\n    const element = freeUntilDeadline[i];\r\n    if (element.value < hours && hours != 0) {\r\n      var event = generateEvent(overlapedEvent.summary,\r\n        overlapedEvent.location,\r\n        overlapedEvent.description,\r\n        overlapedEvent.colorId,\r\n        element.startHour.toISOString(),\r\n        element.endHour.toISOString());\r\n      addEventClick(event);\r\n      hours = hours - element.value;\r\n     console.log('comparison');\r\n     freeTime.splice(i,1);\r\n     console.log(freeTime);\r\n    }\r\n    else if (element.value >= hours && hours != 0) {\r\n      var event = generateEvent(overlapedEvent.summary,\r\n        overlapedEvent.location,\r\n        overlapedEvent.description,\r\n        overlapedEvent.colorId,\r\n        element.startHour.toISOString(),\r\n        element.startHour.addHours(hours / 60).toISOString());\r\n      addEventClick(event);\r\n      hours = 0;\r\n      //delete from free time\r\n      freeTime.splice(i,1);\r\n      console.log(freeTime);\r\n      break;\r\n    }\r\n    else {\r\n      break;\r\n    }\r\n  }\r\n  console.log(hours);\r\n  if (hours > 0) {\r\n    var notMandatory = [];\r\n    for (let i = 0; i < notMandatoryEvents.length; i++) {\r\n      const element = notMandatoryEvents[i];\r\n      if (new Date(element.end.dateTime) < deadline)\r\n        notMandatory.push(element);\r\n    }\r\n    console.log(notMandatory);\r\n    for (let i = 0; i < notMandatory.length; i++) {\r\n      const element = notMandatory[i];\r\n      var value = (new Date(element.end.dateTime) - new Date(element.start.dateTime)) / 1000 / 60;\r\n      console.log(value);\r\n\r\n      if (hours > value && hours != 0) {\r\n        deleteEventClick(element.id);\r\n        var event = generateEvent(overlapedEvent.summary,\r\n          overlapedEvent.location,\r\n          overlapedEvent.description,\r\n          overlapedEvent.colorId,\r\n          element.start.dateTime,\r\n          element.end.dateTime);\r\n        addEventClick(event);\r\n        console.log(event);\r\n        hours = hours - value;\r\n        notMandatoryEvents.splice(i,1);\r\n      }\r\n      else if (hours <= value && hours != 0) {\r\n        deleteEventClick(element.id);\r\n        var event = generateEvent(overlapedEvent.summary,\r\n          overlapedEvent.location,\r\n          overlapedEvent.description,\r\n          overlapedEvent.colorId,\r\n          element.start.dateTime,\r\n          (new Date(element.start.dateTime)).addHours(hours / 60).toISOString());\r\n        console.log(event);\r\n        addEventClick(event);\r\n        notMandatoryEvents.splice(i,1);\r\n        hours = 0;\r\n        break;\r\n      }\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log(hours);\r\n  if (hours > 0) {\r\n    var reasignable = [];\r\n    for (let i = 0; i < mandatoryEvents.length; i++) {\r\n      const element = mandatoryEvents[i];\r\n      if (new Date(element.description.split('|')[0]) > deadline) {\r\n        reasignable.push(element);\r\n      }\r\n    }\r\n    console.log(reasignable);\r\n    for (let i = 0; i < reasignable.length; i++) {\r\n      const element = reasignable[i];\r\n      var value = (new Date(element.end.dateTime) - new Date(element.start.dateTime)) / 1000 / 60;\r\n      console.log(value);\r\n      if (hours > value && hours != 0) {\r\n        deleteEventClick(element.id);\r\n        var event = generateEvent(overlapedEvent.summary,\r\n          overlapedEvent.location,\r\n          overlapedEvent.description,\r\n          overlapedEvent.colorId,\r\n          element.start.dateTime,\r\n          element.end.dateTime);\r\n        addEventClick(event);\r\n        console.log(event);\r\n        hours = hours - value;\r\n        mandatoryEvents.splice(i,1);\r\n        reasign(deadline, element);\r\n      }\r\n      else if (hours <= value && hours != 0) {\r\n        deleteEventClick(element.id);\r\n        var event = generateEvent(overlapedEvent.summary,\r\n          overlapedEvent.location,\r\n          overlapedEvent.description,\r\n          overlapedEvent.colorId,\r\n          element.start.dateTime,\r\n          (new Date(element.start.dateTime)).addHours(hours / 60).toISOString());\r\n        console.log(event);\r\n        addEventClick(event);\r\n        hours = 0;\r\n        mandatoryEvents.splice(i,1);\r\n        reasign(deadline, element);\r\n        break;\r\n      }\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (hours > 0) {\r\n    appendPre(hours + \" minutes from event : \" + overlapedEvent.summary + \" cannot be reasigned automatically.\");\r\n  }\r\n}\r\n\r\nfunction submitForm() {\r\n  // data from forms\r\n  var summary = document.getElementById(\"summary\").value;\r\n  var location = document.getElementById(\"location\").value;\r\n  var description = document.getElementById(\"description\").value;\r\n  var type = document.getElementById(\"type\").value;\r\n  var reminder = document.getElementById(\"reminder\").value;\r\n  var start = document.getElementById(\"start\").value;\r\n  var end = document.getElementById(\"end\").value;\r\n  var hours = document.getElementById(\"hours\").value;\r\n  var deadline = document.getElementById(\"deadline\").value;\r\n\r\n  //select method of adding depending on type\r\n  var startTime = new Date(start).toISOString();\r\n  var endTime = new Date(end).toISOString();\r\n\r\n  var cannotBeAdded = true;\r\n  switch (type) {\r\n    case t.FIXED: {\r\n      var overlaps = [];\r\n      cannotBeAdded = false;\r\n      for (let i = 0; i < allEvents.length; i++) {\r\n        if (haveOverlap(new Date(allEvents[i].start.dateTime), new Date(allEvents[i].end.dateTime)\r\n          , new Date(startTime), new Date(endTime))) {\r\n          if (allEvents[i].colorId === t.FIXED) {\r\n            appendPre('Cannot be added because there is already a fixed event on this interval : ' + allEvents[i].summary);\r\n            cannotBeAdded = true;\r\n            break;\r\n          }\r\n          overlaps.push(allEvents[i]);\r\n        }\r\n      };\r\n\r\n      if (overlaps.length > 0) {\r\n        for (let i = 0; i < overlaps.length; i++) {\r\n          if (overlaps[i].colorId === t.EAT || overlaps[i].colorId === t.OTHER || overlaps.PARTY) {\r\n            deleteEventClick(overlaps[i].eventId);\r\n          }\r\n          else if (overlaps[i].colorId === t.CLASS || overlaps[i].colorId === t.WORK || overlaps.SLEEP) {\r\n            //delete partially\r\n            deletePartially(new Date(startTime), new Date(endTime), overlaps[i]);\r\n          }\r\n          else if (overlaps[i].colorId === t.ASSIGNMENT) {\r\n            //reasign\r\n            reasign(new Date(endTime), overlaps[i]);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case t.ASSIGNMENT: {\r\n      break;\r\n    }\r\n    case t.OTHER: {\r\n      for (i = 0; i < freeTime.length; i++) {\r\n        if (freeTime[i].endHour <= new Date(deadline) && parseInt(hours) * 60 <= freeTime[i].value) {\r\n          startTime = new Date(freeTime[i].startHour).toISOString();\r\n          endTime = (freeTime[i].startHour.addHours(parseInt(hours))).toISOString();\r\n          description = deadline + '|' + description;\r\n          cannotBeAdded = false;\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case t.PARTY: {\r\n      break;\r\n    }\r\n  }\r\n  generateEvent(summary, location, description, type, startTime, endTime);\r\n\r\n\r\n  if (!cannotBeAdded) {\r\n    addEventClick(event);\r\n  }\r\n  else {\r\n    appendPre(\"Event : \" + summary + \" cannot be added\");\r\n  }\r\n\r\n  //addEventClick(seed[0]);\r\n}\r\n\r\nfunction selectRecurrence(type) {\r\n  if (type === t.CLASS ||\r\n    type === t.WORK ||\r\n    type === t.SLEEP ||\r\n    type === t.EAT) {\r\n    return 'FREQ=WEEKLY;COUNT=0';\r\n  }\r\n  else {\r\n    return 'FREQ=DAILY;COUNT=1';\r\n  }\r\n}\r\n\r\nfunction generateEvent(summary, location, description, type, startTime, endTime) {\r\n  return event = {\r\n    'summary': summary,\r\n    'location': location,\r\n    'description': description,\r\n    'colorId': type,\r\n    'start': {\r\n      'dateTime': startTime,\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': endTime,\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'     //+ selectRecurrence(type)\r\n    ]\r\n  };\r\n}\r\n\r\nfunction seed() {\r\n  //seed with events\r\n  for (let i = 0; i < Seed.length; i++) {\r\n    addEventClick(Seed[i]);\r\n  }\r\n}\r\n\r\nfunction deleteAll() {\r\n  for (let i = 0; i < allEvents.length; i++) {\r\n    const element = allEvents[i];\r\n    deleteEventClick(element.id);\r\n  }\r\n}\r\nvar Seed = [\r\n  {\r\n    'summary': 'Assignment',\r\n    'location': 'location',\r\n    'description': '2017-12-07T08:00:00+01:00|description',\r\n    'colorId': t.ASSIGNMENT,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-06T08:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-06T15:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Cooking',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.EAT,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-06T15:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-06T18:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Assignment second',\r\n    'location': 'location',\r\n    'description': '2017-12-08T20:00:00+01:00|description',\r\n    'colorId': t.ASSIGNMENT,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-06T20:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-06T22:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Party',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.PARTY,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-06T22:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-07T00:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Sleep',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.SLEEP,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-07T00:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-07T08:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Classes',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.CLASS,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-07T10:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-07T14:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Cooking ',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.EAT,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-07T15:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-07T16:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Work',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.WORK,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-07T17:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-07T22:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n  {\r\n    'summary': 'Sleep',\r\n    'location': 'location',\r\n    'description': 'description',\r\n    'colorId': t.SLEEP,\r\n    'start': {\r\n      'dateTime': new Date('2017-12-08T00:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'end': {\r\n      'dateTime': new Date('2017-12-08T08:00:00+01:00').toISOString(),\r\n      'timeZone': 'Europe/Budapest'\r\n    },\r\n    'recurrence': [\r\n      'RRULE:FREQ=DAILY;COUNT=1'\r\n    ]\r\n  },\r\n];\r\n","$(document).ready(function() {\r\n});\r\n"]}